

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Levenshtein module &mdash; Levenshtein 0.23.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />

  
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=2753bf86"></script>
      <script src="_static/doctools.js?v=9bcbadda"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="&lt;no title&gt;" href="changelog.html" />
    <link rel="prev" title="Installation" href="installation.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            Levenshtein
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Installation:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Usage:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Levenshtein module</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#distance">distance</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#Levenshtein.distance"><code class="docutils literal notranslate"><span class="pre">distance()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#ratio">ratio</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#Levenshtein.ratio"><code class="docutils literal notranslate"><span class="pre">ratio()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#hamming">hamming</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#Levenshtein.hamming"><code class="docutils literal notranslate"><span class="pre">hamming()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#jaro">jaro</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#Levenshtein.jaro"><code class="docutils literal notranslate"><span class="pre">jaro()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#jaro-winkler">jaro_winkler</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#Levenshtein.jaro_winkler"><code class="docutils literal notranslate"><span class="pre">jaro_winkler()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#median">median</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#Levenshtein.median"><code class="docutils literal notranslate"><span class="pre">median()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#median-improve">median_improve</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#Levenshtein.median_improve"><code class="docutils literal notranslate"><span class="pre">median_improve()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#quickmedian">quickmedian</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#Levenshtein.quickmedian"><code class="docutils literal notranslate"><span class="pre">quickmedian()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#setmedian">setmedian</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#Levenshtein.setmedian"><code class="docutils literal notranslate"><span class="pre">setmedian()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#seqratio">seqratio</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#Levenshtein.seqratio"><code class="docutils literal notranslate"><span class="pre">seqratio()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#setratio">setratio</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#Levenshtein.setratio"><code class="docutils literal notranslate"><span class="pre">setratio()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#editops">editops</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#Levenshtein.editops"><code class="docutils literal notranslate"><span class="pre">editops()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#opcodes">opcodes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#Levenshtein.opcodes"><code class="docutils literal notranslate"><span class="pre">opcodes()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#inverse">inverse</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#Levenshtein.inverse"><code class="docutils literal notranslate"><span class="pre">inverse()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#apply-edit">apply_edit</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#Levenshtein.apply_edit"><code class="docutils literal notranslate"><span class="pre">apply_edit()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#matching-blocks">matching_blocks</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#Levenshtein.matching_blocks"><code class="docutils literal notranslate"><span class="pre">matching_blocks()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#subtract-edit">subtract_edit</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#Levenshtein.subtract_edit"><code class="docutils literal notranslate"><span class="pre">subtract_edit()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Levenshtein</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Levenshtein module</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/levenshtein.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="levenshtein-module">
<h1>Levenshtein module<a class="headerlink" href="#levenshtein-module" title="Link to this heading"></a></h1>
<section id="distance">
<h2>distance<a class="headerlink" href="#distance" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="Levenshtein.distance">
<span class="sig-prename descclassname"><span class="pre">Levenshtein.</span></span><span class="sig-name descname"><span class="pre">distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s2</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(1,</span> <span class="pre">1,</span> <span class="pre">1)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">processor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">score_cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">score_hint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Levenshtein.distance" title="Link to this definition"></a></dt>
<dd><p>Calculates the minimum number of insertions, deletions, and substitutions
required to change one sequence into the other according to Levenshtein with custom
costs for insertion, deletion and substitution</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>s1</strong> (<em>Sequence</em><em>[</em><em>Hashable</em><em>]</em>) – First string to compare.</p></li>
<li><p><strong>s2</strong> (<em>Sequence</em><em>[</em><em>Hashable</em><em>]</em>) – Second string to compare.</p></li>
<li><p><strong>weights</strong> (<em>Tuple</em><em>[</em><em>int</em><em>, </em><em>int</em><em>, </em><em>int</em><em>] or </em><em>None</em><em>, </em><em>optional</em>) – The weights for the three operations in the form
(insertion, deletion, substitution). Default is (1, 1, 1),
which gives all three operations a weight of 1.</p></li>
<li><p><strong>processor</strong> (<em>callable</em><em>, </em><em>optional</em>) – Optional callable that is used to preprocess the strings before
comparing them. Default is None, which deactivates this behaviour.</p></li>
<li><p><strong>score_cutoff</strong> (<em>int</em><em>, </em><em>optional</em>) – Maximum distance between s1 and s2, that is
considered as a result. If the distance is bigger than score_cutoff,
score_cutoff + 1 is returned instead. Default is None, which deactivates
this behaviour.</p></li>
<li><p><strong>score_hint</strong> (<em>int</em><em>, </em><em>optional</em>) – Expected distance between s1 and s2. This is used to select a
faster implementation. Default is None, which deactivates this behaviour.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>distance</strong> – distance between s1 and s2</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If unsupported weights are provided a ValueError is thrown</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Find the Levenshtein distance between two strings:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Levenshtein</span> <span class="kn">import</span> <span class="n">distance</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">distance</span><span class="p">(</span><span class="s2">&quot;lewenstein&quot;</span><span class="p">,</span> <span class="s2">&quot;levenshtein&quot;</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
<p>Setting a maximum distance allows the implementation to select
a more efficient implementation:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">distance</span><span class="p">(</span><span class="s2">&quot;lewenstein&quot;</span><span class="p">,</span> <span class="s2">&quot;levenshtein&quot;</span><span class="p">,</span> <span class="n">score_cutoff</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
<p>It is possible to select different weights by passing a <cite>weight</cite>
tuple.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">distance</span><span class="p">(</span><span class="s2">&quot;lewenstein&quot;</span><span class="p">,</span> <span class="s2">&quot;levenshtein&quot;</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="ratio">
<h2>ratio<a class="headerlink" href="#ratio" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="Levenshtein.ratio">
<span class="sig-prename descclassname"><span class="pre">Levenshtein.</span></span><span class="sig-name descname"><span class="pre">ratio</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s2</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">processor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">score_cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Levenshtein.ratio" title="Link to this definition"></a></dt>
<dd><p>Calculates a normalized indel similarity in the range [0, 1].
The indel distance calculates the minimum number of insertions and deletions
required to change one sequence into the other.</p>
<p>This is calculated as <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">-</span> <span class="pre">(distance</span> <span class="pre">/</span> <span class="pre">(len1</span> <span class="pre">+</span> <span class="pre">len2))</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>s1</strong> (<em>Sequence</em><em>[</em><em>Hashable</em><em>]</em>) – First string to compare.</p></li>
<li><p><strong>s2</strong> (<em>Sequence</em><em>[</em><em>Hashable</em><em>]</em>) – Second string to compare.</p></li>
<li><p><strong>processor</strong> (<em>callable</em><em>, </em><em>optional</em>) – Optional callable that is used to preprocess the strings before
comparing them. Default is None, which deactivates this behaviour.</p></li>
<li><p><strong>score_cutoff</strong> (<em>float</em><em>, </em><em>optional</em>) – Optional argument for a score threshold as a float between 0 and 1.0.
For norm_sim &lt; score_cutoff 0 is returned instead. Default is 0,
which deactivates this behaviour.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>norm_sim</strong> – normalized similarity between s1 and s2 as a float between 0 and 1.0</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Find the normalized Indel similarity between two strings:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Levenshtein</span> <span class="kn">import</span> <span class="n">ratio</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ratio</span><span class="p">(</span><span class="s2">&quot;lewenstein&quot;</span><span class="p">,</span> <span class="s2">&quot;levenshtein&quot;</span><span class="p">)</span>
<span class="go">0.85714285714285</span>
</pre></div>
</div>
<p>Setting a score_cutoff allows the implementation to select
a more efficient implementation:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ratio</span><span class="p">(</span><span class="s2">&quot;lewenstein&quot;</span><span class="p">,</span> <span class="s2">&quot;levenshtein&quot;</span><span class="p">,</span> <span class="n">score_cutoff</span><span class="o">=</span><span class="mf">0.9</span><span class="p">)</span>
<span class="go">0.0</span>
</pre></div>
</div>
<p>When a different processor is used s1 and s2 do not have to be strings</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ratio</span><span class="p">([</span><span class="s2">&quot;lewenstein&quot;</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;levenshtein&quot;</span><span class="p">],</span> <span class="n">processor</span><span class="o">=</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">0.8571428571428572</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="hamming">
<h2>hamming<a class="headerlink" href="#hamming" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="Levenshtein.hamming">
<span class="sig-prename descclassname"><span class="pre">Levenshtein.</span></span><span class="sig-name descname"><span class="pre">hamming</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s2</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pad</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">processor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">score_cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Levenshtein.hamming" title="Link to this definition"></a></dt>
<dd><p>Calculates the Hamming distance between two strings.
The hamming distance is defined as the number of positions
where the two strings differ. It describes the minimum
amount of substitutions required to transform s1 into s2.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>s1</strong> (<em>Sequence</em><em>[</em><em>Hashable</em><em>]</em>) – First string to compare.</p></li>
<li><p><strong>s2</strong> (<em>Sequence</em><em>[</em><em>Hashable</em><em>]</em>) – Second string to compare.</p></li>
<li><p><strong>pad</strong> (<em>bool</em><em>, </em><em>optional</em>) – should strings be padded if there is a length difference.
If pad is False and strings have a different length
a ValueError is thrown instead. Default is True.</p></li>
<li><p><strong>processor</strong> (<em>callable</em><em>, </em><em>optional</em>) – Optional callable that is used to preprocess the strings before
comparing them. Default is None, which deactivates this behaviour.</p></li>
<li><p><strong>score_cutoff</strong> (<em>int</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Maximum distance between s1 and s2, that is
considered as a result. If the distance is bigger than score_cutoff,
score_cutoff + 1 is returned instead. Default is None, which deactivates
this behaviour.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>distance</strong> – distance between s1 and s2</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If s1 and s2 have a different length</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="jaro">
<h2>jaro<a class="headerlink" href="#jaro" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="Levenshtein.jaro">
<span class="sig-prename descclassname"><span class="pre">Levenshtein.</span></span><span class="sig-name descname"><span class="pre">jaro</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s2</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">processor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">score_cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#Levenshtein.jaro" title="Link to this definition"></a></dt>
<dd><p>Calculates the jaro similarity</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>s1</strong> (<em>Sequence</em><em>[</em><em>Hashable</em><em>]</em>) – First string to compare.</p></li>
<li><p><strong>s2</strong> (<em>Sequence</em><em>[</em><em>Hashable</em><em>]</em>) – Second string to compare.</p></li>
<li><p><strong>processor</strong> (<em>callable</em><em>, </em><em>optional</em>) – Optional callable that is used to preprocess the strings before
comparing them. Default is None, which deactivates this behaviour.</p></li>
<li><p><strong>score_cutoff</strong> (<em>float</em><em>, </em><em>optional</em>) – Optional argument for a score threshold as a float between 0 and 1.0.
For ratio &lt; score_cutoff 0 is returned instead. Default is None,
which deactivates this behaviour.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>similarity</strong> – similarity between s1 and s2 as a float between 0 and 1.0</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="jaro-winkler">
<h2>jaro_winkler<a class="headerlink" href="#jaro-winkler" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="Levenshtein.jaro_winkler">
<span class="sig-prename descclassname"><span class="pre">Levenshtein.</span></span><span class="sig-name descname"><span class="pre">jaro_winkler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s2</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prefix_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">processor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">score_cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#Levenshtein.jaro_winkler" title="Link to this definition"></a></dt>
<dd><p>Calculates the jaro winkler similarity</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>s1</strong> (<em>Sequence</em><em>[</em><em>Hashable</em><em>]</em>) – First string to compare.</p></li>
<li><p><strong>s2</strong> (<em>Sequence</em><em>[</em><em>Hashable</em><em>]</em>) – Second string to compare.</p></li>
<li><p><strong>prefix_weight</strong> (<em>float</em><em>, </em><em>optional</em>) – Weight used for the common prefix of the two strings.
Has to be between 0 and 0.25. Default is 0.1.</p></li>
<li><p><strong>processor</strong> (<em>callable</em><em>, </em><em>optional</em>) – Optional callable that is used to preprocess the strings before
comparing them. Default is None, which deactivates this behaviour.</p></li>
<li><p><strong>score_cutoff</strong> (<em>float</em><em>, </em><em>optional</em>) – Optional argument for a score threshold as a float between 0 and 1.0.
For ratio &lt; score_cutoff 0 is returned instead. Default is None,
which deactivates this behaviour.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>similarity</strong> – similarity between s1 and s2 as a float between 0 and 1.0</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If prefix_weight is invalid</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="median">
<h2>median<a class="headerlink" href="#median" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="Levenshtein.median">
<span class="sig-prename descclassname"><span class="pre">Levenshtein.</span></span><span class="sig-name descname"><span class="pre">median</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">strlist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wlist</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Levenshtein.median" title="Link to this definition"></a></dt>
<dd><p>Find an approximate generalized median string using greedy algorithm.</p>
<p>You can optionally pass a weight for each string as the second
argument. The weights are interpreted as item multiplicities,
although any non-negative real numbers are accepted. Use them to
improve computation speed when strings often appear multiple times
in the sequence.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">median</span><span class="p">([</span><span class="s1">&#39;SpSm&#39;</span><span class="p">,</span> <span class="s1">&#39;mpamm&#39;</span><span class="p">,</span> <span class="s1">&#39;Spam&#39;</span><span class="p">,</span> <span class="s1">&#39;Spa&#39;</span><span class="p">,</span> <span class="s1">&#39;Sua&#39;</span><span class="p">,</span> <span class="s1">&#39;hSam&#39;</span><span class="p">])</span>
<span class="go">&#39;Spam&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fixme</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Levnhtein&#39;</span><span class="p">,</span> <span class="s1">&#39;Leveshein&#39;</span><span class="p">,</span> <span class="s1">&#39;Leenshten&#39;</span><span class="p">,</span>
<span class="gp">... </span>         <span class="s1">&#39;Leveshtei&#39;</span><span class="p">,</span> <span class="s1">&#39;Lenshtein&#39;</span><span class="p">,</span> <span class="s1">&#39;Lvenstein&#39;</span><span class="p">,</span>
<span class="gp">... </span>         <span class="s1">&#39;Levenhtin&#39;</span><span class="p">,</span> <span class="s1">&#39;evenshtei&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">median</span><span class="p">(</span><span class="n">fixme</span><span class="p">)</span>
<span class="go">&#39;Levenshtein&#39;</span>
</pre></div>
</div>
<p>Hm. Even a computer program can spell Levenshtein better than me.</p>
</dd></dl>

</section>
<section id="median-improve">
<h2>median_improve<a class="headerlink" href="#median-improve" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="Levenshtein.median_improve">
<span class="sig-prename descclassname"><span class="pre">Levenshtein.</span></span><span class="sig-name descname"><span class="pre">median_improve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strlist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wlist</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Levenshtein.median_improve" title="Link to this definition"></a></dt>
<dd><p>Improve an approximate generalized median string by perturbations.</p>
<p>The first argument is the estimated generalized median string you
want to improve, the others are the same as in median(). It returns
a string with total distance less or equal to that of the given string.</p>
<p>Note this is much slower than median(). Also note it performs only
one improvement step, calling median_improve() again on the result
may improve it further, though this is unlikely to happen unless the
given string was not very similar to the actual generalized median.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fixme</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Levnhtein&#39;</span><span class="p">,</span> <span class="s1">&#39;Leveshein&#39;</span><span class="p">,</span> <span class="s1">&#39;Leenshten&#39;</span><span class="p">,</span>
<span class="gp">... </span>         <span class="s1">&#39;Leveshtei&#39;</span><span class="p">,</span> <span class="s1">&#39;Lenshtein&#39;</span><span class="p">,</span> <span class="s1">&#39;Lvenstein&#39;</span><span class="p">,</span>
<span class="gp">... </span>         <span class="s1">&#39;Levenhtin&#39;</span><span class="p">,</span> <span class="s1">&#39;evenshtei&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">median_improve</span><span class="p">(</span><span class="s1">&#39;spam&#39;</span><span class="p">,</span> <span class="n">fixme</span><span class="p">)</span>
<span class="go">&#39;enhtein&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">median_improve</span><span class="p">(</span><span class="n">median_improve</span><span class="p">(</span><span class="s1">&#39;spam&#39;</span><span class="p">,</span> <span class="n">fixme</span><span class="p">),</span> <span class="n">fixme</span><span class="p">)</span>
<span class="go">&#39;Levenshtein&#39;</span>
</pre></div>
</div>
<p>It takes some work to change spam to Levenshtein.</p>
</dd></dl>

</section>
<section id="quickmedian">
<h2>quickmedian<a class="headerlink" href="#quickmedian" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="Levenshtein.quickmedian">
<span class="sig-prename descclassname"><span class="pre">Levenshtein.</span></span><span class="sig-name descname"><span class="pre">quickmedian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">strlist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wlist</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Levenshtein.quickmedian" title="Link to this definition"></a></dt>
<dd><p>Find a very approximate generalized median string, but fast.</p>
<p>See median() for argument description.</p>
<p>This method is somewhere between setmedian() and picking a random
string from the set; both speedwise and quality-wise.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fixme</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Levnhtein&#39;</span><span class="p">,</span> <span class="s1">&#39;Leveshein&#39;</span><span class="p">,</span> <span class="s1">&#39;Leenshten&#39;</span><span class="p">,</span>
<span class="gp">... </span>        <span class="s1">&#39;Leveshtei&#39;</span><span class="p">,</span> <span class="s1">&#39;Lenshtein&#39;</span><span class="p">,</span> <span class="s1">&#39;Lvenstein&#39;</span><span class="p">,</span>
<span class="gp">... </span>        <span class="s1">&#39;Levenhtin&#39;</span><span class="p">,</span> <span class="s1">&#39;evenshtei&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">quickmedian</span><span class="p">(</span><span class="n">fixme</span><span class="p">)</span>
<span class="go">&#39;Levnshein&#39;</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="setmedian">
<h2>setmedian<a class="headerlink" href="#setmedian" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="Levenshtein.setmedian">
<span class="sig-prename descclassname"><span class="pre">Levenshtein.</span></span><span class="sig-name descname"><span class="pre">setmedian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">strlist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wlist</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Levenshtein.setmedian" title="Link to this definition"></a></dt>
<dd><p>Find set median of a string set (passed as a sequence).</p>
<p>See median() for argument description.</p>
<p>The returned string is always one of the strings in the sequence.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">setmedian</span><span class="p">([</span><span class="s1">&#39;ehee&#39;</span><span class="p">,</span> <span class="s1">&#39;cceaes&#39;</span><span class="p">,</span> <span class="s1">&#39;chees&#39;</span><span class="p">,</span> <span class="s1">&#39;chreesc&#39;</span><span class="p">,</span>
<span class="gp">... </span>           <span class="s1">&#39;chees&#39;</span><span class="p">,</span> <span class="s1">&#39;cheesee&#39;</span><span class="p">,</span> <span class="s1">&#39;cseese&#39;</span><span class="p">,</span> <span class="s1">&#39;chetese&#39;</span><span class="p">])</span>
<span class="go">&#39;chees&#39;</span>
</pre></div>
</div>
<p>You haven’t asked me about Limburger, sir.</p>
</dd></dl>

</section>
<section id="seqratio">
<h2>seqratio<a class="headerlink" href="#seqratio" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="Levenshtein.seqratio">
<span class="sig-prename descclassname"><span class="pre">Levenshtein.</span></span><span class="sig-name descname"><span class="pre">seqratio</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">strlist1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strlist2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Levenshtein.seqratio" title="Link to this definition"></a></dt>
<dd><p>Compute similarity ratio of two sequences of strings.</p>
<p>This is like ratio(), but for string sequences. A kind of ratio()
is used to to measure the cost of item change operation for the
strings.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">seqratio</span><span class="p">([</span><span class="s1">&#39;newspaper&#39;</span><span class="p">,</span> <span class="s1">&#39;litter bin&#39;</span><span class="p">,</span> <span class="s1">&#39;tinny&#39;</span><span class="p">,</span> <span class="s1">&#39;antelope&#39;</span><span class="p">],</span>
<span class="gp">... </span>         <span class="p">[</span><span class="s1">&#39;caribou&#39;</span><span class="p">,</span> <span class="s1">&#39;sausage&#39;</span><span class="p">,</span> <span class="s1">&#39;gorn&#39;</span><span class="p">,</span> <span class="s1">&#39;woody&#39;</span><span class="p">])</span>
<span class="go">0.215178</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="setratio">
<h2>setratio<a class="headerlink" href="#setratio" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="Levenshtein.setratio">
<span class="sig-prename descclassname"><span class="pre">Levenshtein.</span></span><span class="sig-name descname"><span class="pre">setratio</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">strlist1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strlist2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Levenshtein.setratio" title="Link to this definition"></a></dt>
<dd><p>Compute similarity ratio of two strings sets (passed as sequences).</p>
<p>The best match between any strings in the first set and the second
set (passed as sequences) is attempted. I.e., the order doesn’t
matter here.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">setratio</span><span class="p">([</span><span class="s1">&#39;newspaper&#39;</span><span class="p">,</span> <span class="s1">&#39;litter bin&#39;</span><span class="p">,</span> <span class="s1">&#39;tinny&#39;</span><span class="p">,</span> <span class="s1">&#39;antelope&#39;</span><span class="p">],</span>
<span class="gp">... </span>         <span class="p">[</span><span class="s1">&#39;caribou&#39;</span><span class="p">,</span> <span class="s1">&#39;sausage&#39;</span><span class="p">,</span> <span class="s1">&#39;gorn&#39;</span><span class="p">,</span> <span class="s1">&#39;woody&#39;</span><span class="p">])</span>
<span class="go">0.281845</span>
</pre></div>
</div>
<p>No, even reordering doesn’t help the tinny words to match the
woody ones.</p>
</dd></dl>

</section>
<section id="editops">
<h2>editops<a class="headerlink" href="#editops" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="Levenshtein.editops">
<span class="sig-prename descclassname"><span class="pre">Levenshtein.</span></span><span class="sig-name descname"><span class="pre">editops</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Levenshtein.editops" title="Link to this definition"></a></dt>
<dd><p>Find sequence of edit operations transforming one string to another.</p>
<p>editops(source_string, destination_string)
editops(edit_operations, source_length, destination_length)</p>
<p>The result is a list of triples (operation, spos, dpos), where
operation is one of ‘equal’, ‘replace’, ‘insert’, or ‘delete’;  spos
and dpos are position of characters in the first (source) and the
second (destination) strings.  These are operations on single
characters.  In fact the returned list doesn’t contain the ‘equal’,
but all the related functions accept both lists with and without
‘equal’s.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">editops</span><span class="p">(</span><span class="s1">&#39;spam&#39;</span><span class="p">,</span> <span class="s1">&#39;park&#39;</span><span class="p">)</span>
<span class="go">[(&#39;delete&#39;, 0, 0), (&#39;insert&#39;, 3, 2), (&#39;replace&#39;, 3, 3)]</span>
</pre></div>
</div>
<p>The alternate form editops(opcodes, source_string, destination_string)
can be used for conversion from opcodes (5-tuples) to editops (you can
pass strings or their lengths, it doesn’t matter).</p>
</dd></dl>

</section>
<section id="opcodes">
<h2>opcodes<a class="headerlink" href="#opcodes" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="Levenshtein.opcodes">
<span class="sig-prename descclassname"><span class="pre">Levenshtein.</span></span><span class="sig-name descname"><span class="pre">opcodes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Levenshtein.opcodes" title="Link to this definition"></a></dt>
<dd><p>Find sequence of edit operations transforming one string to another.</p>
<p>opcodes(source_string, destination_string)
opcodes(edit_operations, source_length, destination_length)</p>
<p>The result is a list of 5-tuples with the same meaning as in
SequenceMatcher’s get_opcodes() output.  But since the algorithms
differ, the actual sequences from Levenshtein and SequenceMatcher
may differ too.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">opcodes</span><span class="p">(</span><span class="s1">&#39;spam&#39;</span><span class="p">,</span> <span class="s1">&#39;park&#39;</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">(&#39;delete&#39;, 0, 1, 0, 0)</span>
<span class="go">(&#39;equal&#39;, 1, 3, 0, 2)</span>
<span class="go">(&#39;insert&#39;, 3, 3, 2, 3)</span>
<span class="go">(&#39;replace&#39;, 3, 4, 3, 4)</span>
</pre></div>
</div>
<p>The alternate form opcodes(editops, source_string, destination_string)
can be used for conversion from editops (triples) to opcodes (you can
pass strings or their lengths, it doesn’t matter).</p>
</dd></dl>

</section>
<section id="inverse">
<h2>inverse<a class="headerlink" href="#inverse" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="Levenshtein.inverse">
<span class="sig-prename descclassname"><span class="pre">Levenshtein.</span></span><span class="sig-name descname"><span class="pre">inverse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edit_operations</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Levenshtein.inverse" title="Link to this definition"></a></dt>
<dd><p>Invert the sense of an edit operation sequence.</p>
<p>In other words, it returns a list of edit operations transforming the
second (destination) string to the first (source).  It can be used
with both editops and opcodes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>edit_operations</strong> (<em>list</em><em>[</em><em>]</em>) – edit operations to invert</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>edit_operations</strong> – inverted edit operations</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list[]</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">editops</span><span class="p">(</span><span class="s1">&#39;spam&#39;</span><span class="p">,</span> <span class="s1">&#39;park&#39;</span><span class="p">)</span>
<span class="go">[(&#39;delete&#39;, 0, 0), (&#39;insert&#39;, 3, 2), (&#39;replace&#39;, 3, 3)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inverse</span><span class="p">(</span><span class="n">editops</span><span class="p">(</span><span class="s1">&#39;spam&#39;</span><span class="p">,</span> <span class="s1">&#39;park&#39;</span><span class="p">))</span>
<span class="go">[(&#39;insert&#39;, 0, 0), (&#39;delete&#39;, 2, 3), (&#39;replace&#39;, 3, 3)]</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="apply-edit">
<h2>apply_edit<a class="headerlink" href="#apply-edit" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="Levenshtein.apply_edit">
<span class="sig-prename descclassname"><span class="pre">Levenshtein.</span></span><span class="sig-name descname"><span class="pre">apply_edit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edit_operations</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source_string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">destination_string</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Levenshtein.apply_edit" title="Link to this definition"></a></dt>
<dd><p>Apply a sequence of edit operations to a string.</p>
<p>apply_edit(edit_operations, source_string, destination_string)</p>
<p>In the case of editops, the sequence can be arbitrary ordered subset
of the edit sequence transforming source_string to destination_string.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">editops</span><span class="p">(</span><span class="s1">&#39;man&#39;</span><span class="p">,</span> <span class="s1">&#39;scotsman&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">apply_edit</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="s1">&#39;man&#39;</span><span class="p">,</span> <span class="s1">&#39;scotsman&#39;</span><span class="p">)</span>
<span class="go">&#39;scotsman&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">apply_edit</span><span class="p">(</span><span class="n">e</span><span class="p">[:</span><span class="mi">3</span><span class="p">],</span> <span class="s1">&#39;man&#39;</span><span class="p">,</span> <span class="s1">&#39;scotsman&#39;</span><span class="p">)</span>
<span class="go">&#39;scoman&#39;</span>
</pre></div>
</div>
<p>The other form of edit operations, opcodes, is not very suitable for
such a tricks, because it has to always span over complete strings,
subsets can be created by carefully replacing blocks with ‘equal’
blocks, or by enlarging ‘equal’ block at the expense of other blocks
and adjusting the other blocks accordingly.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="s1">&#39;spam and eggs&#39;</span><span class="p">,</span> <span class="s1">&#39;foo and bar&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">opcodes</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">apply_edit</span><span class="p">(</span><span class="n">inverse</span><span class="p">(</span><span class="n">e</span><span class="p">),</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="go">&#39;spam and eggs&#39;</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="matching-blocks">
<h2>matching_blocks<a class="headerlink" href="#matching-blocks" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="Levenshtein.matching_blocks">
<span class="sig-prename descclassname"><span class="pre">Levenshtein.</span></span><span class="sig-name descname"><span class="pre">matching_blocks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edit_operations</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source_string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">destination_string</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Levenshtein.matching_blocks" title="Link to this definition"></a></dt>
<dd><p>Find identical blocks in two strings.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>edit_operations</strong> (<em>list</em><em>[</em><em>]</em>) – editops or opcodes created for the source and destination string</p></li>
<li><p><strong>source_string</strong> (<em>str</em><em> | </em><em>int</em>) – source string or the length of the source string</p></li>
<li><p><strong>destination_string</strong> (<em>str</em><em> | </em><em>int</em>) – destination string or the length of the destination string</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>matching_blocks</strong> – List of triples with the same meaning as in SequenceMatcher’s
get_matching_blocks() output.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list[]</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="s1">&#39;spam&#39;</span><span class="p">,</span> <span class="s1">&#39;park&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">matching_blocks</span><span class="p">(</span><span class="n">editops</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">[(1, 0, 2), (4, 4, 0)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">matching_blocks</span><span class="p">(</span><span class="n">editops</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
<span class="go">[(1, 0, 2), (4, 4, 0)]</span>
</pre></div>
</div>
<p>The last zero-length block is not an error, but it’s there for
compatibility with difflib which always emits it.</p>
<p>One can join the matching blocks to get two identical strings:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="s1">&#39;dog kennels&#39;</span><span class="p">,</span> <span class="s1">&#39;mattresses&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mb</span> <span class="o">=</span> <span class="n">matching_blocks</span><span class="p">(</span><span class="n">editops</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">),</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">a</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">mb</span><span class="p">])</span>
<span class="go">&#39;ees&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">b</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">mb</span><span class="p">])</span>
<span class="go">&#39;ees&#39;</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="subtract-edit">
<h2>subtract_edit<a class="headerlink" href="#subtract-edit" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="Levenshtein.subtract_edit">
<span class="sig-prename descclassname"><span class="pre">Levenshtein.</span></span><span class="sig-name descname"><span class="pre">subtract_edit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edit_operations</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subsequence</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Levenshtein.subtract_edit" title="Link to this definition"></a></dt>
<dd><p>Subtract an edit subsequence from a sequence.</p>
<p>subtract_edit(edit_operations, subsequence)</p>
<p>The result is equivalent to
editops(apply_edit(subsequence, s1, s2), s2), except that is
constructed directly from the edit operations.  That is, if you apply
it to the result of subsequence application, you get the same final
string as from application complete edit_operations.  It may be not
identical, though (in amibuous cases, like insertion of a character
next to the same character).</p>
<p>The subtracted subsequence must be an ordered subset of
edit_operations.</p>
<p>Note this function does not accept difflib-style opcodes as no one in
his right mind wants to create subsequences from them.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">editops</span><span class="p">(</span><span class="s1">&#39;man&#39;</span><span class="p">,</span> <span class="s1">&#39;scotsman&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e1</span> <span class="o">=</span> <span class="n">e</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bastard</span> <span class="o">=</span> <span class="n">apply_edit</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="s1">&#39;man&#39;</span><span class="p">,</span> <span class="s1">&#39;scotsman&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bastard</span>
<span class="go">&#39;scoman&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">apply_edit</span><span class="p">(</span><span class="n">subtract_edit</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">e1</span><span class="p">),</span> <span class="n">bastard</span><span class="p">,</span> <span class="s1">&#39;scotsman&#39;</span><span class="p">)</span>
<span class="go">&#39;scotsman&#39;</span>
</pre></div>
</div>
</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="installation.html" class="btn btn-neutral float-left" title="Installation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="changelog.html" class="btn btn-neutral float-right" title="&lt;no title&gt;" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, Max Bachmann.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>